---
layout: single
title:  "0726 언리얼 강의"
categories: Memo
tag: [UE5]
toc: true
toc_sticky: true
published : true
sidebar:
    nav: "counts"
---
### 쿼터니온

* 회전 행렬
    * 

* 오일러 각
    * yaw , roll , pitch 
        * 돌리는 순서에 따라 기준축이 달라져서 결과값이 달라짐

    * 짐벌락 문제
        
* 쿼터니온
    * 사원수 x ,y ,z, w
    * 

# 2024-07-26

* 서브시스템
    * 보조체계

* 카메라
    * 절두체 : 
* 

# 2024-07-31

* FSM 
    * 깊이가 깊어지면 제어하기 어려워짐 ( 세분화 가 어려움)
    * 깊이가 깊어지면 Behavior Tree 를 써서 제어하는게 나을수 있음

* AnimInstance
    * AnimGraph : 애니메이션 배치하는 공간 , 
    *        

* 벡터 곱
    * 벡터 dot 벡터 : 내적
        * 결과가 스칼라
    * 벡터 corss 벡터 : 외적
        * 결과가 벡터  -> 노멀 방향 

```cpp
void UTPSPlayerAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	ATPSPlayer* player = Cast<ATPSPlayer>(TryGetPawnOwner());
	if ( nullptr == player )
	{
		return;
	}

	FVector velocity = player->GetVelocity();
	FVector forwardVector = player->GetActorForwardVector();
	FVector rightVector = player->GetActorRightVector();

	// 앞 뒤 속도 
        // 여기서 기준이 forward , 이동방향에 따라 항상변하는게 velocity
        // 기준이되는 forward 와 나의 이동방향이 뒤라면 이루는 각도가 180도 => Cos(180) = -1 
	Speed = FVector::DotProduct(forwardVector , velocity);

	// 좌우 속도
        // 여기서 기준이 right , 이동방향에 따라 항상변하는게 velocity
        // 기준이되는 right 와 나의 이동방향이 왼쪽이된다면 이루는 각도가 180도 => Cos(180) = -1 
	Direction = FVector::DotProduct(rightVector , velocity);

}
```

* BlendSpace
<img width="1280" alt="Snipaste_2024-07-31_13-54-50" src="https://github.com/user-attachments/assets/10e4c651-ed0a-4967-b812-b965b566e9f5">


# 2024-08-01

* 

# 2024-08-06

* State Machine
    * Sub State Machine
        