---
layout: single
title:  "0701  언리얼 강의"
categories: Memo
tag: [UE5]
toc: true
toc_sticky: true
sidebar:
    nav: "counts"
---

# 2024-07-01

![image](https://github.com/silverlnng/UE_FarmGame/assets/112385982/a1419fd8-8e1a-4436-8d8e-32654629a7fe)

- development editor 으로 설정하고 빌드

- 솔루션이 여러 솔루션을 가지는 구조 
    - 게임 아래 폴더에 있는 프로젝트를 시작프로젝트로 설정해야 함
    - 솔루션을 열어서 컴파일을 거쳐 

- UnrealBuildTool ( UBT) / 언리얼 헤더툴 (UHT)
    - 언리얼 헤더 툴 :  UCLASS()를 상속받은 것들을 모두 수집 , 
    - 카피해서 또 하나 생성 ? 
    - #include "CodingPawn.generated.h" 는 해더파일의 제일 맨마지막에 위치해야함
    - 
- 빌드툴이 sln 파일을 다시 만들어 주는 것

- 라이브코딩 켜져있으면 다른 프로젝트 열려있음 안열림 끄기 !! 
    - 
- 
- UE_LOG : 매크로

- 언리얼은 UTF 16 

- #pragma once : 헤더를 한번만 로드 될수있도록 막아주는 역할 ?
    - 

- editorConfig : 한글나오게 설정하기

- TArray 의 슬랙 : 벡터의 capacity . 미리 용량을 크게 잡아 두는 것 .
    - 그래서 복사하는 횟수를 적게하기 위하여 
![image](https://github.com/silverlnng/UE_FarmGame/assets/112385982/6799af7d-d0cd-4612-933c-d56dfe43f097)

# 2024-07-02

* UPROPERTY
    * https://docs.unrealengine.com/4.27/ko/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Objects/Optimizations/
    * 언리얼에서 인지할수있는 변수로 만들어진다.
        * 내가 만든 클래스를 
    * 리플렉션
    * 

* edit 할수있는 곳이 3 부분이 됨 : 소스코드 ,블루프린트 , 레벨에 배치한뒤 아웃라이너에서
    * 우선순위 레벨에 배치한뒤 아웃라이너 > 블루프린트>소스코드
    * 이 3가지 모두가 수정된다 = 저장이 된다 = 직렬화 

* 가비지 컬렉션 마크앤스윕
    * 포인터를 관리 delete하는게 아니라 / 스마트포인터는 레퍼런스 카운팅 
        * 특히 언리얼에서 ui ...
    * 

* BlueprintCallable 
    * 블루프린트가 C++클래스의 상속을 받는다 
    * 부모는 자식을 모름 / 자식은 부모를 안다
    * 부모의 함수를 자식이 상속받게 해주는 효과 

* BlueprintPure
    * 
* BlueprintImplementableEvent
    * 함수의 구현부를 블루프린트쪽에서 만 구현.

* BlueprintNativeEvent
    * 함수의 구현을 블루프린트 + c++ 에서도 가능 (확장한다는 개념)

* 언리얼의 Class
    * 언리얼 엔진이 열리는 순간 UCLASS() , CDO 인스턴스 생성 
        * UCLASS() : 언리얼 객체 . 1개만 생성됨
            * 리플렉션 에서 활용. (나중에 만들어진 클래스를 엔진에서 해석하기 위한 장치)  
            * UPROPERTY ,UFUNCTION  으로 설정해줘야 리플렉션 데이터로 알수있음
            * 
            * 언리얼에서 Cast 가 uclass 인지를 검증하는 것.
    * 개발자가 만드는 것은 CDO 인스턴스
        * 개체 생성을 한번만 하고 , 메모리 카피를 이용 => 메모리 퍼포먼스를 올림  
            * 두번째 생성 부터는 생성자를 거쳐서 만들어지지 않음   
    * 그래서 결론적으로 2개의 클래스가 만들어 지는 것


# 2024-07-03

* 언리얼의 접두사 : 언리얼의 헤더툴이 해석하는 데 필요하기 때문에 필수
    * 액터 : A
    * 액터를 제외한 UObject : U
        * 

* include 를 헤더파일에 하지말고 , 소스파일에서 include 를 하기 
    * <https://dev.epicgames.com/documentation/ko-kr/unreal-engine/include-what-you-use-iwyu-for-unreal-engine-programming>
    * 헤더에서는 전방선언을 하자 
    * 

* 블루프린트 노드 더블클릭 -> c++ 에서 어떻게 쓰이는지 알수있음
    * <img width="706" alt="Snipaste_2024-07-03_12-26-09" src="https://github.com/silverlnng/UnrealKirbyProject/assets/112385982/7da4469f-68dc-43cc-a378-fac7ddea0e9a">


* 컴포넌트 3가지 상속구조
    * <https://dev.epicgames.com/documentation/ko-kr/unreal-engine/components-in-unreal-engine?application_version=5.3>
    * 액터 컴포넌트 : 가장 기본이 되는 컴포넌트
    * 씬 컴포넌트 : 액터 컴포넌트 를 상속받음. Transform 이 이때부터 존재
    * primitive component : 씬 컴포넌트를 상속받음. Collision 이 있어서 물리적인 작용 
        * 충돌체 컴포넌트를 알아야할때

* ::StaticClass() : UCLASS 반환

* IsValidLowLevel()
    * 유효성 체크        

* GetSafeNormal()
    * 원본을 복사해서 노말한 값을 반환.
    * .Normalize() 는 원본값 자체를 노말화시키는 것. 차이가 있음

* 전략패턴- 상속의 불편함을 해소

# 2024-07-24

* mesh 와 충돌체를 별개로 
    * 
* NewObject

* instigator : 행위를 한 주체 .

* Outer : has-a 관계에서 소유자. 박스 컴포넌트의 소유자 플레이어 
    * is-a : 상속
    * has-a : 소유

* Owner : 언리얼에서 구조상 소유자 . 플레이어-플레이어컨트롤러 에서 플레이어컨트롤러가 소유자.    


* CTRL +F5 : 디버그하지않고 실행

* F5 번 : 디버그 로 실행 . 에러찾는데 활용할수있음

*  파일 입출력
	* 파일 스트림 