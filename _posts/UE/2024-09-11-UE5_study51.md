---
layout: single
title:  "UE5_Study51 매크로, 네트워크"
categories: UE5
tag: [UE5]
toc: true
toc_sticky: true
sidebar:
    nav: "counts"
---

# 로그 를 위한  매크로 만들기 

```cpp

DECLARE_LOG_CATEGORY_EXTERN(NetLog, Log, All); // 카테고리를 설정

#define LOCALROLE (UEnum::GetValueAsString<ENetRole>(GetLocalRole()))
#define REMOTEROLE (UEnum::GetValueAsString<ENetRole>(GetRemoteRole()))
#define NETMODE (GetNetMode()==ENetMode::NM_Client?TEXT("client"):GetNetMode()==ENetMode::NM_Standalone ?TEXT("Standalone"):TEXT("Server"))
#define CALLINFO (FString(__FUNCTION__)+TEXT("(") + FString::FromInt(__LINE__) +TEXT(")"))
#define PRINTLOG(fmt, ...) UE_LOG(NetLog,Warning,TEXT("[%s]%s : %s"),NETMODE,*CALLINFO,*FString::Printf(fmt,##__VA_ARGS__))

```

* #define NETMODE (GetNetMode()==ENetMode::NM_Client?TEXT("client"):GetNetMode()==ENetMode::NM_Standalone ?TEXT("Standalone"):TEXT("Server"))
	* NETMODE 라는 매크로에 지금 GetNetMode 에 따라서  값이나오도록 설정 


*  #define LOG_CALLINFO (FString(__FUNCTION__) + TEXT("(") + FString::FromInt(__LINE__) + TEXT(")")) 	
	* 이 함수가 호출된 함수의 이름과 라인을 매크로로 String화 시킴

* #define PRINTLOG(fmt, ...) UE_LOG(NetLog,Warning,TEXT("[%s]%s : %s"),NETMODE,*CALLINFO,*FString::Printf(fmt,##__VA_ARGS__)) 
	* 차례대로 정의한 NETMODE , CALLINFO, fmt 출력


# 네트워크 수업 2024-09-11

* 서버방

(1) 맨처음 서버가 서버캐릭터를	PossessedBy 됨 ==> 이 때부터 컨트롤러 가지게 됨

(2) 서버캐릭터 의 beginplay 에서 initWidget 실행

(3) 서버가 서버가 아닌 클라이언트는 beginplay 먼저 실행

(4) 그리고 서버방에서 서버가 아닌 클라이언트 가 PossessedBy 실행

* 클라이언트 방

(5) 클라이언트 방에서 로컬 클라이언트가  beginplay 에서 initWidget 실행 ==> 이떄 컨트롤러 있음
(5)-1. 클라이언트 방에서 로컬클라이언트는 플레이어컨트롤러 possess하고 beginplay 실행
(6) 클라이언트 방에서 서버의  beginplay 에서 initWidget 실행 


<img width="1193" alt="Snipaste_2024-09-11_16-56-12" src="https://github.com/user-attachments/assets/8934e3f9-df3d-407f-88e4-e2ee3dbab2d0">


* 서버방에서 서버가 죽은다음 리스폰 될떄 : RestartPlayer 으로 리스폰

(1) 서버방에서 서버가 beginplay -> initwidget 먼저함 (이떄 컨트롤러 없음)
	-> RestartPlayer 가 그런 절차임

(2) 그 후 플레이어 컨트롤러 PossessedBy (컨트롤러 있음)

<img width="792" alt="Snipaste_2024-09-11_17-05-49" src="https://github.com/user-attachments/assets/1203fc5a-eebf-4a62-9562-825c250a27b8">


## 왜 관전자 모드로 변경도 ChangeToSpectator ServerRPC으로 실행 ??

* 플레이어 possess 도 서버RPC으로 실행하여야함
	* 클라이언트에서만 possess 대상을 바꾸면 문제가된다 
	* 서버 , 클라이언트방 각각 의 플레이어가 possess 한게 다르면 문제가 된다 !
	* PlayerController 자체가 통신의 대상으로 서버에서만 possess 변경해도 모든 방에서 변경하는 효과 

* Possess(APawn* InPawn) : 함수 들어가보면 	!HasAuthority() 권한이 없는 경우 경고출력하도록 되어있음 

```cpp
void AController::Possess(APawn* InPawn)
{
	if (!bCanPossessWithoutAuthority && !HasAuthority())
	{
		FMessageLog("PIE").Warning(FText::Format(
			LOCTEXT("ControllerPossessAuthorityOnly", "Possess function should only be used by the network authority for {0}"),
			FText::FromName(GetFName())
			));
		UE_LOG(LogController, Warning, TEXT("Trying to possess %s without network authority! Request will be ignored."), *GetNameSafe(InPawn));
		return;
	}

	REDIRECT_OBJECT_TO_VLOG(InPawn, this);

	APawn* CurrentPawn = GetPawn();

	// A notification is required when the current assigned pawn is not possessed (i.e. pawn assigned before calling Possess)
	const bool bNotificationRequired = (CurrentPawn != nullptr) && (CurrentPawn->GetController() == nullptr);

	// To preserve backward compatibility we keep notifying derived classed for null pawn in case some
	// overrides decided to react differently when asked to possess a null pawn.
	// Default engine implementation is to unpossess the current pawn.
	OnPossess(InPawn);

	// Notify when pawn to possess (different than the assigned one) has been accepted by the native class or notification is explicitly required
	APawn* NewPawn = GetPawn();
	if ((NewPawn != CurrentPawn) || bNotificationRequired)
	{
		ReceivePossess(NewPawn);
		OnNewPawn.Broadcast(NewPawn);
		OnPossessedPawnChanged.Broadcast(bNotificationRequired ? nullptr : CurrentPawn, NewPawn);
	}
	
	TRACE_PAWN_POSSESS(this, InPawn); 
}
```