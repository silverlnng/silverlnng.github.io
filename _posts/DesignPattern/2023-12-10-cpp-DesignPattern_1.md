---
layout: single
title:  "C++_DesignPattern_1_전략패턴"
categories: DesignPattern
tag: [C++]
toc: true
toc_sticky: true
sidebar:
    nav: "counts"
---

# 전략패턴 

## 전략패턴의 목적
   
변화가 자주일어나는 부분을 캡슐화 해서 부모클래스에서 독립적으로 만드는 것
   
* OCP : 확장에는 열려있고 변경에는 닫혀있어야 하는 원칙   

## 상속의 한계점

상속으로 변화가 자주일어나는 부분을 부모클래스에서 순수가상함수로 만들고 , 자식클래스에서 override해서 재정의 하게 만들었을때의 문제점

모든 

## 추상클래스
   
*   Pure Virtual Function을 한개 라도 가지면 추상클래스가 되고(=불안전해지고) , 인스턴스를 만들지 못함 
    * Pure Virtual Function는 반드시 자식클래스에서 구현을 해야한다.

## Virtual 함수
* 파생클래스에서 재정의할 것으로 기대하는 함수
    * 반드시 재정의를 해야하는 함수가 아니라, 재정의가 가능한 함수
* Pure Virtual 함수의 경우 반드시 재정의.     
    
* Virtual Function 동적바인딩 
    * 가상함수가 아닌 멤버함수는 모두 정적바인딩 = 함수를 호출할때 함수가 어느 블록에 있는지 , 함수가 저장된 메모리 위치까지 알아햐 한다
       
    * 가상함수의 호출은 컴파일러가 어떤 함수를 호출해야하는지 미리 알 수 없다 .   
     왜나하면 프로그램이 실행될때 객체를 결정하므로. 컴파일 타임에는 객체를 특정할수없다.   
     그래서 런타임 시전에 올바른 함수가 실행될수있도록 하는데 이를 동적바인딩 또는 지연바인딩이라고 합니다.
           
    * 이러한 가상함수는 기초클래스 타입의 포인터나 참조를 통하여 호출될때만 동적바인딩을 하게 됩니다.

## 인터페이스
   
* 모든 메소드가 Pure Virtual Function
    * 따라서 인터페이스에는 구현부가 없고 , 인터페이스를 상속받는 클래스들은 인터페이스 안에있는 모든 함수를 전부 오버라이딩 해야한다   
    * 인터페이스는 일종의 추상클래스. 마찬가지로 인스턴스 만들지 못함
       



## 헤드퍼스트 오리 예제로 공부하기 

